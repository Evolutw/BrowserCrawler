// == å®Œæ•´çˆ¬è™«æ–¹æ¡ˆï¼ˆåŠ¨æ€é¡µæ•°ç‰ˆï¼‰==
(async function() {
    // ========== åˆå§‹åŒ–ä¾èµ–åŠ è½½ ==========
    try {
        if (!window.JSZip) {
            const script1 = document.createElement('script');
            script1.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
            document.head.appendChild(script1);
            await new Promise(resolve => setTimeout(resolve, 2000));
        }
        
        if (!window.XLSX) {
            const script2 = document.createElement('script');
            script2.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
            document.head.appendChild(script2);
            await new Promise(resolve => setTimeout(resolve, 2000));
        }
    } catch (e) {
        alert('ä¾èµ–åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
        return;
    }

    // ========== ç”¨æˆ·æ–‡ä»¶é€‰æ‹© ==========
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.xlsx,.xls';
    input.style.position = 'fixed';
    input.style.left = '-9999px';
    document.body.appendChild(input);

    let excelData = [], excelHeaders = [], excelMap = new Map();
    const allExcelKeys = new Set(); // æ–°å¢ï¼šè®°å½•æ‰€æœ‰Excelé”®
    
    try {
        const { headers, data } = await new Promise(resolve => {
            input.onchange = async function(e) {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const workbook = XLSX.read(new Uint8Array(e.target.result), {type: 'array'});
                        const sheet = workbook.Sheets[workbook.SheetNames[0]];
                        const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                        resolve({
                            headers: jsonData[0] || [],
                            data: jsonData.slice(1).filter(row => row.length > 0)
                        });
                    } catch (error) {
                        alert('Excelè§£æé”™è¯¯ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼');
                        resolve({ headers: [], data: [] });
                    }
                };
                reader.readAsArrayBuffer(file);
            };
            input.click();
        });

        excelData = data;
        excelHeaders = headers.map((h, i) => h || 'åˆ—' + (i + 1));
        
        // ä½¿ç”¨å§“å+è¯ä»¶å·æ•°å­—ä½œä¸ºåŒ¹é…é”®
        data.forEach(row => {
            if (row.length < 2) return;
            
            const name = String(row[0] || '').trim().toLowerCase();
            const id = String(row[1] || '').replace(/\D/g, '').toLowerCase();
            
            if (name && id) {
                const key = `${name}_${id}`;
                excelMap.set(key, row);
                allExcelKeys.add(key); // è®°å½•æ‰€æœ‰Excelé”®
            }
        });
    } catch (e) {
        alert('Excelå¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•');
        return;
    } finally {
        if (input.parentNode) {
            document.body.removeChild(input);
        }
    }

    // ========== é…ç½®åŒº ==========
    const CONFIG = {
        DELAY: 2000,            // ç¿»é¡µå»¶è¿Ÿ(æ¯«ç§’)
        ZIP_PREFIX: 'ä¸šåŠ¡å‘˜æ•°æ®', // å‹ç¼©åŒ…å‰ç¼€
        PAGE_SIZE: 500,          // æ¯é¡µæ˜¾ç¤ºæ•°é‡ï¼ˆç”¨äºè®¡ç®—æ€»é¡µæ•°ï¼‰
        MAX_RETRY: 5,            // æœ€å¤§é‡è¯•æ¬¡æ•°
        FIELD_MAPPINGS: {        // è¡¨å¤´æ˜ å°„é…ç½®ï¼ˆæ”¯æŒå¤šä¸ªåŒ¹é…åç§°ï¼‰
            "å§“å": ["å§“å", "å®¢æˆ·åç§°"],
            "è¯ä»¶å·": ["è¯ä»¶å·", "è¯ä»¶å·ç "],
            "ä¸šåŠ¡å‘˜": ["ä¸šåŠ¡å‘˜", "å®¢æˆ·ç»ç†", "CPE"]
        },
        REQUIRED_FIELDS: ["å§“å", "è¯ä»¶å·"] // å¿…å¡«å­—æ®µæ ¡éªŒ
    };

    // ========== å·¥å…·å‡½æ•° ==========
    function waitForElement(selector, timeout = 10000) {
        return new Promise((resolve, reject) => {
            const start = Date.now();
            const check = () => {
                const element = document.querySelector(selector);
                if (element) {
                    resolve(element);
                } else if (Date.now() - start > timeout) {
                    reject(new Error(`å…ƒç´ åŠ è½½è¶…æ—¶: ${selector}`));
                } else {
                    setTimeout(check, 100);
                }
            };
            check();
        });
    }

    // ========== æ ¸å¿ƒå‡½æ•° ==========
    function createHeaderMapper() {
        const headerCells = Array.from(document.querySelectorAll('thead th, .el-table__header th'));
        const headers = headerCells.map(th => th.innerText.trim().replace(/\s+/g, ''));
        
        const mapper = {};
        let missingFields = [];

        Object.entries(CONFIG.FIELD_MAPPINGS).forEach(([fieldName, aliases]) => {
            const foundIndex = headers.findIndex(header => 
                aliases.some(alias => header.includes(alias))
            );

            if (foundIndex >= 0) {
                const cell = headerCells[foundIndex];
                const colIndex = Array.from(cell.parentNode.children).indexOf(cell) + 1;
                
                mapper[fieldName] = {
                    selector: `td:nth-child(${colIndex}) .cell`,
                    index: foundIndex,
                    headerText: headers[foundIndex]
                };
            } else {
                missingFields.push(fieldName);
                console.warn(`æœªæ‰¾åˆ°è¡¨å¤´åŒ¹é…: ${fieldName} (å°è¯•åŒ¹é…: ${aliases.join(', ')})`);
            }
        });

        // æ£€æŸ¥å¿…å¡«å­—æ®µ
        const missingRequired = CONFIG.REQUIRED_FIELDS.filter(f => !mapper[f]);
        if (missingRequired.length > 0) {
            throw new Error(`ç¼ºå°‘å¿…è¦å­—æ®µ: ${missingRequired.join(', ')}`);
        }

        console.log('è¡¨å¤´æ˜ å°„ç»“æœ:', JSON.stringify(mapper, null, 2));
        return mapper;
    }

    // ========== é¡µæ•°è®¡ç®—å‡½æ•° ==========
    function calculateTotalPages() {
        const totalText = document.querySelector('.el-pagination__total')?.innerText || 
                         document.querySelector('.pagination-total')?.innerText ||
                         '0';
        const totalMatch = totalText.match(/[\d,]+/);
        const total = totalMatch ? parseInt(totalMatch[0].replace(/,/g, '')) : 0;
        return Math.ceil(total / CONFIG.PAGE_SIZE);
    }

    // ========== æ•°æ®æå–å‡½æ•° ==========
    function extractRowData(row, mapper) {
        const data = {};
        
        Object.entries(mapper).forEach(([fieldName, {selector}]) => {
            const cell = row.querySelector(selector);
            let value = cell?.textContent?.trim() || '';
            
            // å­—æ®µç‰¹å®šå¤„ç†
            if (fieldName === "è¯ä»¶å·") {
                value = value.replace(/\D/g, '');
            }
            
            data[fieldName] = value;
        });

        const name = data['å§“å'].toLowerCase();
        const id = data['è¯ä»¶å·'].toLowerCase();
        const salesman = data['ä¸šåŠ¡å‘˜'] || 'æœªåˆ†é…';

        if (!name || !id) return null;

        const key = `${name}_${id}`;
        return {
            webData: { name, id, salesman },
            excelRow: excelMap.get(key)
        };
    }

    // ========== ç¿»é¡µæŠ“å–å‡½æ•° ==========
    async function fetchAllPages() {
        // ç­‰å¾…è¡¨å¤´åŠ è½½å¹¶åˆ›å»ºæ˜ å°„
        await waitForElement('thead th, .el-table__header th', 15000);
        const headerMapper = createHeaderMapper();
        
        const allRows = [];
        let currentPage = 1;
        const totalPages = calculateTotalPages();
        
        console.log(`ğŸ“Š æ€»é¡µæ•°: ${totalPages} (æ¯é¡µ ${CONFIG.PAGE_SIZE} æ¡)`);
        
        while (currentPage <= totalPages) {
            let retry = 0;
            let success = false;
            
            while (retry < CONFIG.MAX_RETRY) {
                try {
                    console.log(`[ç¬¬${currentPage}é¡µ] å°è¯•${retry+1}/${CONFIG.MAX_RETRY}`);
                    
                    // 1. è·å–å½“å‰é¡µæ•°æ®
                    const rows = Array.from(document.querySelectorAll('tr.el-table__row'));
                    const pageData = rows.map(row => extractRowData(row, headerMapper)).filter(Boolean);
                    allRows.push(...pageData);
                    console.log(`ğŸ“‹ å½“å‰é¡µé‡‡é›†åˆ° ${pageData.length} æ¡æœ‰æ•ˆæ•°æ®`);
                    
                    // 2. ä¸‹ä¸€é¡µæŒ‰é’®æ£€æµ‹
                    const nextBtn = document.querySelector('.btn-next:not(.is-disabled)');
                    const isLastPage = !nextBtn || nextBtn.classList.contains('is-disabled');
                    
                    if (isLastPage || currentPage >= totalPages) {
                        console.log('ğŸ›‘ å·²åˆ°è¾¾æœ€åä¸€é¡µ');
                        return allRows;
                    }
                    
                    // 3. æ‰§è¡Œç¿»é¡µ
                    currentPage++;
                    nextBtn.click();
                    await new Promise(resolve => setTimeout(resolve, CONFIG.DELAY));
                    success = true;
                    break;
                    
                } catch (e) {
                    console.warn(`[é”™è¯¯] ${e.message}`);
                    if (++retry >= CONFIG.MAX_RETRY) throw e;
                    await new Promise(r => setTimeout(r, 2000));
                }
            }
            
            if (!success) break;
        }
        
        console.log(`âœ… é‡‡é›†å®Œæˆï¼Œå…±å¤„ç† ${currentPage} é¡µï¼Œè·å¾— ${allRows.length} æ¡æ•°æ®`);
        return allRows;
    }

    // ========== æ–‡ä»¶ç”Ÿæˆå‡½æ•° ==========
    async function generateZip(data) {
        return new Promise(async (resolve) => {
            console.log('ğŸ—œï¸ å¼€å§‹ç”Ÿæˆå‹ç¼©æ–‡ä»¶...');
            const zip = new JSZip();
            const salesMap = new Map();
            
            // ç»Ÿè®¡ä¿¡æ¯
            let matchedCount = 0;
            let unmatchedCount = 0;
            const uniqueKeys = new Set();
            const matchedKeys = new Set(); // æ–°å¢ï¼šè®°å½•å·²åŒ¹é…çš„é”®

            // 1. æ•°æ®å»é‡å¤„ç†
            data.forEach(item => {
                if (!item.excelRow) {
                    unmatchedCount++;
                    return;
                }
                
                // ä½¿ç”¨æ›´å¯é çš„é”®æ ¼å¼
                const key = `${item.webData.name}_${item.webData.id}`;
                if (uniqueKeys.has(key)) {
                    console.log(`âš ï¸ å‘ç°é‡å¤æ•°æ®: ${key}`);
                    return;
                }
                uniqueKeys.add(key);
                matchedKeys.add(key); // è®°å½•å·²åŒ¹é…çš„é”®
                matchedCount++;
                
                const salesman = item.webData.salesman.replace(/[/\\?%*:|"<>]/g, '_');
                if (!salesMap.has(salesman)) {
                    salesMap.set(salesman, []);
                }
                salesMap.get(salesman).push(item.excelRow);
            });
            
            console.log(`ğŸ” åŒ¹é…ç»“æœ: ${matchedCount}æ¡åŒ¹é…, ${unmatchedCount}æ¡æœªåŒ¹é…`);
            
            // æ–°å¢ï¼šæ‰“å°å‰10æ¡æœªåŒ¹é…çš„Excelæ•°æ®
            const unmatchedExcelKeys = [...allExcelKeys].filter(key => !matchedKeys.has(key));
            if (unmatchedExcelKeys.length > 0) {
                console.log("âš ï¸ ä»¥ä¸‹ä¸ºå‰10æ¡æœªåŒ¹é…çš„Excelæ•°æ®:");
                unmatchedExcelKeys.slice(0, 10).forEach(key => {
                    const row = excelMap.get(key);
                    if (row && row.length >= 2) {
                        console.log(`  - å§“å: ${row[0]}, è¯ä»¶å·: ${row[1]}`);
                    }
                });
                console.log(`âš ï¸ å…± ${unmatchedExcelKeys.length} æ¡Excelæ•°æ®æœªåŒ¹é…`);
            } else {
                console.log("âœ… æ‰€æœ‰Excelæ•°æ®å‡å·²åŒ¹é…");
            }

            let all = 0;
            // 2. ç”ŸæˆCSVæ–‡ä»¶
            salesMap.forEach((rows, salesman) => {
                const headerRow = '\uFEFF' + excelHeaders.join(',');
                const dataRows = rows.map(row => 
                    row.map(cell => 
                        typeof cell === 'string' ? `"${cell.replace(/"/g, '""')}"` : (cell ?? '')
                    ).join(',')
                ).join('\n');
                
                zip.file(`${salesman}.csv`, headerRow + '\n' + dataRows);
                console.log(`ğŸ“„ ç”Ÿæˆæ–‡ä»¶: ${salesman}.csv (${rows.length}æ¡)`);
                all += rows.length;
            });
            console.log(`æ€»æ¡æ•°: ${all}`);


            // 3. ä¸‹è½½ZIP
            const blob = await zip.generateAsync({type: "blob"});
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `${CONFIG.ZIP_PREFIX}_${new Date().toLocaleDateString('zh-CN')}.zip`;
            document.body.appendChild(link);
            link.click();
            
            // 4. æ¸…ç†èµ„æº
            setTimeout(() => {
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
                console.log('ğŸ§¹ ä¸´æ—¶èµ„æºå·²æ¸…ç†');
                resolve();
            }, 100);
        });
    }

    // ========== ä¸»æ‰§è¡Œæµç¨‹ ==========
    try {
        console.log('ğŸš€ å¯åŠ¨æ•°æ®é‡‡é›†ä»»åŠ¡');
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        const matchedData = await fetchAllPages();
        
        if (matchedData.length > 0) {
            console.log(`åŒ¹é…æ•°æ®æ¡æ•°: ${matchedData.length}`);
            await generateZip(matchedData);
            console.log('ğŸ‰ æ–‡ä»¶ç”Ÿæˆå®Œæˆ');
            alert('âœ… æ•°æ®æ–‡ä»¶å·²ç”Ÿæˆå¹¶ä¸‹è½½\nä»»åŠ¡ç»ˆæ­¢è¿è¡Œ');
        } else {
            console.log('âš ï¸ æ— åŒ¹é…æ•°æ®');
            alert('âš ï¸ æœªæ‰¾åˆ°åŒ¹é…æ•°æ®\nä»»åŠ¡ç»ˆæ­¢è¿è¡Œ');
        }
    } catch (e) {
        console.error('âŒ å¤„ç†å¤±è´¥:', e);
        alert(`âŒ å¤„ç†å¤±è´¥: ${e.message}\nä»»åŠ¡ç»ˆæ­¢è¿è¡Œ`);
    } finally {
        console.log('ğŸ”š ç¨‹åºæ‰§è¡Œç»“æŸ');
    }
})();
