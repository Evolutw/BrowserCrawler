// == å®Œæ•´çˆ¬è™«æ–¹æ¡ˆï¼ˆåŠ¨æ€é¡µæ•°ç‰ˆï¼‰==
(async function() {
    // ========== åˆå§‹åŒ–ä¾èµ–åŠ è½½ ==========
    try {
        if (!window.JSZip) {
            const script1 = document.createElement('script');
            script1.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
            document.head.appendChild(script1);
            await new Promise(resolve => setTimeout(resolve, 2000));
        }
        
        if (!window.XLSX) {
            const script2 = document.createElement('script');
            script2.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
            document.head.appendChild(script2);
            await new Promise(resolve => setTimeout(resolve, 2000));
        }
    } catch (e) {
        alert('ä¾èµ–åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
        return;
    }

    // ========== ç”¨æˆ·æ–‡ä»¶é€‰æ‹© ==========
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.xlsx,.xls';
    input.style.position = 'fixed';
    input.style.left = '-9999px';
    document.body.appendChild(input);

    let excelData = [], excelHeaders = [], excelMap = new Map();
    try {
        const { headers, data } = await new Promise(resolve => {
            input.onchange = async function(e) {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const workbook = XLSX.read(new Uint8Array(e.target.result), {type: 'array'});
                        const sheet = workbook.Sheets[workbook.SheetNames[0]];
                        const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                        resolve({
                            headers: jsonData[0] || [],
                            data: jsonData.slice(1).filter(row => row.length > 0)
                        });
                    } catch (error) {
                        alert('Excelè§£æé”™è¯¯ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼');
                        resolve({ headers: [], data: [] });
                    }
                };
                reader.readAsArrayBuffer(file);
            };
            input.click();
        });

        excelData = data;
        excelHeaders = headers.map((h, i) => h || 'åˆ—' + (i + 1));
        
        // ä½¿ç”¨å§“å+è¯ä»¶å·æ•°å­—ä½œä¸ºåŒ¹é…é”®
        const uniqueSet = new Set();
        data.forEach(row => {
            if (row.length < 2) return;
            
            const name = String(row[0] || '').trim();
            const id = String(row[1] || '').replace(/\D/g, '');
            
            if (name && id) {
                const key = `${name}|${id}`;
                if (!uniqueSet.has(key)) {
                    uniqueSet.add(key);
                    excelMap.set(key, row);
                }
            }
        });
    } catch (e) {
        alert('Excelå¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•');
        return;
    } finally {
        if (input.parentNode) {
            document.body.removeChild(input);
        }
    }

    // ========== é…ç½®åŒº ==========
    const CONFIG = {
        DELAY: 2000,            // ç¿»é¡µå»¶è¿Ÿ(æ¯«ç§’)
        ZIP_PREFIX: 'ä¸šåŠ¡å‘˜æ•°æ®', // å‹ç¼©åŒ…å‰ç¼€
        PAGE_SIZE: 500,          // æ¯é¡µæ˜¾ç¤ºæ•°é‡ï¼ˆç”¨äºè®¡ç®—æ€»é¡µæ•°ï¼‰
        COLUMN_MAP: {           // é¡µé¢å…ƒç´ classæ˜ å°„
            å§“å: 'el-table_4_column_22',
            è¯ä»¶å·: 'el-table_4_column_23',
            ä¸šåŠ¡å‘˜: 'el-table_4_column_34'
        }
    };

    // ========== é¡µæ•°è®¡ç®—å‡½æ•° ==========
    function calculateTotalPages() {
        const totalText = document.querySelector('.el-pagination__total')?.innerText || 
                         document.querySelector('.pagination-total')?.innerText ||
                         '0';
        const totalMatch = totalText.match(/[\d,]+/);
        const total = totalMatch ? parseInt(totalMatch[0].replace(/,/g, '')) : 0;
        return Math.ceil(total / CONFIG.PAGE_SIZE);
    }

    // ========== æ•°æ®æå–å‡½æ•° ==========
    function extractRowData(row) {
        function getCellValue(selector) {
            const cell = row.querySelector('td.' + selector + ' .cell');
            return cell ? cell.textContent.trim() : '';
        }

        const name = getCellValue(CONFIG.COLUMN_MAP.å§“å);
        const id = getCellValue(CONFIG.COLUMN_MAP.è¯ä»¶å·).replace(/\D/g, '');
        const salesman = getCellValue(CONFIG.COLUMN_MAP.ä¸šåŠ¡å‘˜) || 'æœªåˆ†é…';

        if (!name || !id) return null;

        const key = `${name}|${id}`;
        return {
            webData: { name, id, salesman },
            excelRow: excelMap.get(key)
        };
    }

    // ========== ç¿»é¡µæŠ“å–å‡½æ•° ==========
    async function fetchAllPages() {
        const allRows = [];
        let currentPage = 1;
        const totalPages = calculateTotalPages();
        
        console.log(`ğŸ“Š æ€»é¡µæ•°: ${totalPages} (æ¯é¡µ ${CONFIG.PAGE_SIZE} æ¡)`);
        
        while (currentPage <= totalPages) {
            console.log(`â³ æ­£åœ¨é‡‡é›†ç¬¬ ${currentPage}/${totalPages} é¡µæ•°æ®...`);
            
            // 1. è·å–å½“å‰é¡µæ•°æ®
            const rows = Array.from(document.querySelectorAll('tr.el-table__row'));
            const pageData = rows.map(row => extractRowData(row)).filter(Boolean);
            allRows.push(...pageData);
            
            // 2. ä¸‹ä¸€é¡µæŒ‰é’®æ£€æµ‹
            const nextBtn = document.querySelector('.btn-next');
            const isLastPage = nextBtn && nextBtn.hasAttribute('disabled');
            
            if (isLastPage) {
                console.log('ğŸ›‘ å·²åˆ°è¾¾æœ€åä¸€é¡µ');
                break;
            }
            
            // 3. æ‰§è¡Œç¿»é¡µ
            currentPage++;
            nextBtn.click();
            await new Promise(resolve => setTimeout(resolve, CONFIG.DELAY));
        }
        
        console.log(`âœ… é‡‡é›†å®Œæˆï¼Œå…±å¤„ç† ${currentPage} é¡µï¼Œè·å¾— ${allRows.length} æ¡æ•°æ®`);
        return allRows;
    }

    // ========== æ–‡ä»¶ç”Ÿæˆå‡½æ•° ==========
    async function generateZip(data) {
        return new Promise(async (resolve) => {
            console.log('ğŸ—œï¸ å¼€å§‹ç”Ÿæˆå‹ç¼©æ–‡ä»¶...');
            const zip = new JSZip();
            const salesMap = new Map();
            const uniqueKeys = new Set();

            // 1. æ•°æ®å»é‡å¤„ç†
            data.forEach(item => {
                if (!item.excelRow) return;
                
                const key = `${item.webData.name}|${item.webData.id}`;
                if (uniqueKeys.has(key)) return;
                uniqueKeys.add(key);
                
                const salesman = item.webData.salesman.replace(/[/\\?%*:|"<>]/g, '_');
                if (!salesMap.has(salesman)) {
                    salesMap.set(salesman, []);
                }
                salesMap.get(salesman).push(item.excelRow);
            });

            // 2. ç”ŸæˆCSVæ–‡ä»¶
            salesMap.forEach((rows, salesman) => {
                const headerRow = '\uFEFF' + excelHeaders.join(',');
                const dataRows = rows.map(row => 
                    row.map(cell => 
                        typeof cell === 'string' ? `"${cell.replace(/"/g, '""')}"` : (cell ?? '')
                    ).join(',')
                ).join('\n');
                
                zip.file(`${salesman}.csv`, headerRow + '\n' + dataRows);
                console.log(`ğŸ“„ ç”Ÿæˆæ–‡ä»¶: ${salesman}.csv (${rows.length}æ¡)`);
            });

            // 3. ä¸‹è½½ZIP
            const blob = await zip.generateAsync({type: "blob"});
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `${CONFIG.ZIP_PREFIX}_${new Date().toLocaleDateString('zh-CN')}.zip`;
            document.body.appendChild(link);
            link.click();
            
            // 4. æ¸…ç†èµ„æº
            setTimeout(() => {
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
                console.log('ğŸ§¹ ä¸´æ—¶èµ„æºå·²æ¸…ç†');
                resolve();
            }, 100);
        });
    }

    // ========== ä¸»æ‰§è¡Œæµç¨‹ ==========
    try {
        console.log('ğŸš€ å¯åŠ¨æ•°æ®é‡‡é›†ä»»åŠ¡');
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        const matchedData = await fetchAllPages();
        
        if (matchedData.length > 0) {
            await generateZip(matchedData);
            console.log('ğŸ‰ æ–‡ä»¶ç”Ÿæˆå®Œæˆ');
            alert('âœ… æ•°æ®æ–‡ä»¶å·²ç”Ÿæˆå¹¶ä¸‹è½½\nä»»åŠ¡ç»ˆæ­¢è¿è¡Œ');
        } else {
            console.log('âš ï¸ æ— åŒ¹é…æ•°æ®');
            alert('âš ï¸ æœªæ‰¾åˆ°åŒ¹é…æ•°æ®\nä»»åŠ¡ç»ˆæ­¢è¿è¡Œ');
        }
    } catch (e) {
        console.error('âŒ å¤„ç†å¤±è´¥:', e);
        alert(`âŒ å¤„ç†å¤±è´¥: ${e.message}\nä»»åŠ¡ç»ˆæ­¢è¿è¡Œ`);
    } finally {
        console.log('ğŸ”š ç¨‹åºæ‰§è¡Œç»“æŸ');
    }
})();